<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Sefaria Copy Tool</title>
  <style>
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 0; padding: 16px; color: #0f172a; background: #f8fafc; }
    h2 { margin-top: 0; }
    .panel { background: #fff; border: 1px solid #e2e8f0; border-radius: 12px; padding: 16px; box-shadow: 0 1px 2px rgba(15, 23, 42, 0.08); max-width: 540px; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    label { display: flex; align-items: center; gap: 8px; font-size: 14px; color: #1e293b; cursor: pointer; }
    input[type="text"] { padding: 8px 10px; border: 1px solid #cbd5f5; border-radius: 8px; width: 260px; background: #f1f5f9; }
    input[type="checkbox"] { width: 16px; height: 16px; }
    button { padding: 8px 12px; border: 1px solid #cbd5f5; border-radius: 8px; background: #e2e8f0; cursor: pointer; font-weight: 500; }
    button.primary { background: #2563eb; border-color: #1d4ed8; color: #fff; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    .options { margin-top: 16px; display: flex; flex-direction: column; gap: 8px; }
    .actions { margin-top: 16px; display: flex; align-items: center; gap: 12px; }
    .muted { font-size: 12px; color: #64748b; }
    .status { font-size: 14px; min-height: 20px; }
    .status.error { color: #b91c1c; }
    .status.success { color: #047857; }
  </style>
</head>
<body>
  <div class="panel">
    <h2>Copy Text</h2>
    <div class="row">
      <div>Current sref:</div>
      <input id="sref" type="text" readonly placeholder="waiting…" />
      <button id="ask">Request sref</button>
    </div>
    <div class="muted" style="margin-top:4px;">Choose what to copy and then hit “Copy”.</div>
    <div class="options">
      <label>
        <input type="checkbox" id="opt-segment" checked>
        Copy segment (e.g. Genesis 1:1)
      </label>
      <label>
        <input type="checkbox" id="opt-section">
        Copy section (e.g. Genesis 1)
      </label>
      <label>
        <input type="checkbox" id="opt-with-ref">
        Copy with ref (prepend the chosen ref)
      </label>
      <label>
        <input type="checkbox" id="opt-he-ref">
        Copy heRef (Hebrew reference)
      </label>
      <label>
        <input type="checkbox" id="opt-source" checked>
        Copy source (Hebrew)
      </label>
      <label>
        <input type="checkbox" id="opt-translation" checked>
        Copy translation (English)
      </label>
    </div>
    <div class="actions">
      <button id="copy" class="primary">Copy</button>
      <div id="status" class="status muted"></div>
    </div>
  </div>

  <script>
    const srefInput = document.getElementById('sref');
    const askBtn = document.getElementById('ask');
    const copyBtn = document.getElementById('copy');
    const statusEl = document.getElementById('status');

    const segmentOpt = document.getElementById('opt-segment');
    const sectionOpt = document.getElementById('opt-section');
    const withRefOpt = document.getElementById('opt-with-ref');
    const heRefOpt = document.getElementById('opt-he-ref');
    const sourceOpt = document.getElementById('opt-source');
    const translationOpt = document.getElementById('opt-translation');

    let currentSref = null;
    const htmlStripper = document.createElement('div');

    function setStatus(message, type = null) {
      statusEl.textContent = message || '';
      statusEl.className = 'status' + (type ? ' ' + type : ' muted');
    }

    function ensurePrimarySelection(source) {
      if (source === segmentOpt && segmentOpt.checked) {
        sectionOpt.checked = false;
      } else if (source === sectionOpt && sectionOpt.checked) {
        segmentOpt.checked = false;
      }
      if (!segmentOpt.checked && !sectionOpt.checked) {
        segmentOpt.checked = true;
      }
    }

    segmentOpt.addEventListener('change', () => ensurePrimarySelection(segmentOpt));
    sectionOpt.addEventListener('change', () => ensurePrimarySelection(sectionOpt));

    function normalizeRef(ref) {
      return (ref || '').trim();
    }

    function stripIHtmlTags(raw) {
      if (raw == null) return '';
      if (typeof raw !== 'string') {
        return stripIHtmlTags(String(raw));
      }
      return raw.replace(/<i[^>]*>(.*?)<\/i>/gi, '$1').trim();
    }

    function stripHtml(raw) {
      if (raw == null) return '';
      if (typeof raw !== 'string') {
        return stripHtml(String(raw));
      }
      htmlStripper.innerHTML = raw;
      const text = htmlStripper.textContent || htmlStripper.innerText || '';
      htmlStripper.textContent = '';
      return text.trim();
    }

    function toSectionRef(ref) {
      const normalized = normalizeRef(ref);
      if (!normalized) return null;
      const dotParts = normalized.split('.');
      if (dotParts.length > 2 && /^\d+$/.test(dotParts[1])) {
        return dotParts.slice(0, 2).join('.');
      }
      const colonIdx = normalized.indexOf(':');
      if (colonIdx !== -1) {
        return normalized.slice(0, colonIdx);
      }
      return normalized;
    }

    function formatDisplayRef(ref) {
      if (!ref) return '';
      const sanitized = ref.replace(/_/g, ' ');
      if (sanitized.includes(':')) {
        return sanitized;
      }
      const dotParts = sanitized.split('.');
      if (dotParts.length >= 2 && /^\d+$/.test(dotParts[1])) {
        const book = dotParts[0];
        const chapter = dotParts[1];
        if (dotParts.length > 2) {
          const versePart = dotParts.slice(2).join('.');
          return `${book} ${chapter}:${versePart}`;
        }
        return `${book} ${chapter}`;
      }
      return sanitized;
    }

    async function copyToClipboard(text) {
      if (!text) {
        throw new Error('Nothing to copy.');
      }
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(text);
        return;
      }
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.setAttribute('readonly', '');
      textarea.style.position = 'absolute';
      textarea.style.left = '-9999px';
      document.body.appendChild(textarea);
      textarea.select();
      try {
        document.execCommand('copy');
      } finally {
        document.body.removeChild(textarea);
      }
    }

    function flattenText(value) {
      if (!value) return '';
      if (Array.isArray(value)) {
        return value.map(flattenText).filter(Boolean).join('\n').trim();
      }
      if (typeof value === 'object') {
        if ('text' in value) return flattenText(value.text);
        if ('he' in value) return flattenText(value.he);
        if ('content' in value) return flattenText(value.content);
        return '';
      }
      if (typeof value === 'string') {
        return stripHtml(value);
      }
      return stripHtml(String(value));
    }

    function normalizeSegment(segment, fallbackRef) {
      if (!segment || typeof segment !== 'object') {
        return { ref: fallbackRef || '', source: '', translation: '' };
      }
      return {
        ref: segment.ref || fallbackRef || '',
        source: flattenText(segment.he || segment.sourceText),
        translation: flattenText(segment.text || segment.translation)
      };
    }

    function extractSegments(apiData) {
      if (!apiData) return [];
      const segments = [];
      const rootRef = apiData.ref || '';

      if (Array.isArray(apiData.content)) {
        for (const section of apiData.content) {
          if (!section) continue;
          const sectionRef = (typeof section === 'object' && section.ref) ? section.ref : rootRef;
          if (section && Array.isArray(section.content)) {
            for (const piece of section.content) {
              segments.push(normalizeSegment(piece, sectionRef));
            }
          } else if (typeof section === 'object') {
            segments.push(normalizeSegment(section, sectionRef));
          } else if (typeof section === 'string') {
            segments.push({ ref: sectionRef, source: '', translation: stripHtml(section) });
          }
        }
      }

      if (segments.length) {
        return segments.filter(seg => seg.source || seg.translation);
      }

      const texts = Array.isArray(apiData.versions[0].text) ? apiData.versions[0].text : (typeof apiData.text === 'string' ? [apiData.versions[0].text] : []);
      const sources = Array.isArray(apiData.he) ? apiData.he : (typeof apiData.he === 'string' ? [apiData.he] : []);
      const maxLen = Math.max(texts.length, sources.length);
      if (maxLen === 0) return [];

      for (let i = 0; i < maxLen; i++) {
        const translation = typeof texts[i] === 'string' ? texts[i].trim() : '';
        const source = typeof sources[i] === 'string' ? sources[i].trim() : '';
        segments.push({ ref: rootRef, source, translation });
      }
      return segments.filter(seg => seg.source || seg.translation);
    }

    async function fetchSefariaSegments(ref) {
      const params = new URLSearchParams({
        context: '0',
        stripItags: '1',
        fallbackOnDefaultVersion: '1'
      });
      const url = `https://www.sefaria.org/api/texts/${encodeURIComponent(ref)}?${params.toString()}`;
      const res = await fetch(url);
      if (!res.ok) {
        throw new Error(`Sefaria API error (${res.status})`);
      }
      const data = await res.json();
      if (data && data.error) {
        throw new Error(data.error);
      }
      const segments = extractSegments(data);
      if (!segments.length) {
        throw new Error('No text returned for that reference.');
      }
      const normalizedRef = normalizeRef(data.ref) || normalizeRef(ref);
      const normalizedHeRef = stripHtml(data.heRef || '');
      return {
        segments,
        ref: normalizedRef,
        heRef: normalizedHeRef
      };
    }

    async function handleCopy() {
      if (!currentSref) {
        setStatus('No reference yet.', 'error');
        return;
      }
      const useSection = sectionOpt.checked;
      const targetRef = useSection ? toSectionRef(currentSref) : normalizeRef(currentSref);
      if (!targetRef) {
        setStatus('Unable to determine reference.', 'error');
        return;
      }
      const includeSource = sourceOpt.checked;
      const includeTranslation = translationOpt.checked;
      const includeHeRef = heRefOpt.checked;

      if (!includeSource && !includeTranslation && !includeHeRef) {
        setStatus('Select something to copy.', 'error');
        return;
      }

      setStatus('Fetching text…');
      copyBtn.disabled = true;
      try {
        const { segments, ref: fetchedRef, heRef } = await fetchSefariaSegments(targetRef);
        const displayRef = formatDisplayRef(fetchedRef || targetRef);
        const displayHeRef = includeHeRef ? stripHtml(heRef || '') : '';
        let body = '';
        if (includeSource || includeTranslation) {
          body = segments
            .map((seg) => {
              const lines = [];
              if (includeSource && seg.source) lines.push(seg.source);
              if (includeTranslation && seg.translation) lines.push(seg.translation);
              return lines.join('\n').trim();
            })
            .filter(Boolean)
            .join('\n\n')
            .trim();
        }

        if (!body && !(includeHeRef && displayHeRef)) {
          throw new Error('No text available for the selected options.');
        }

        const parts = [];
        if (withRefOpt.checked && displayRef) {
          parts.push(displayRef);
        }
        if (includeHeRef && displayHeRef) {
          parts.push(displayHeRef);
        }
        if (body) {
          parts.push(body);
        }
        const combined = parts.join('\n').trim();
        await copyToClipboard(combined);
        setStatus('Copied to clipboard!', 'success');
      } catch (err) {
        console.error(err);
        setStatus(err.message || 'Failed to copy.', 'error');
      } finally {
        copyBtn.disabled = false;
      }
    }

    function handleSrefUpdate(newSref) {
      currentSref = normalizeRef(newSref);
      srefInput.value = currentSref || '';
      if (!currentSref) {
        setStatus('Waiting for reference…');
      } else {
        setStatus('');
      }
    }

    window.addEventListener('message', (event) => {
      const data = event.data;
      if (!data || typeof data !== 'object') return;
      if (data.type === 'sref:update' || data.type === 'sref:response') {
        handleSrefUpdate(data.sref || null);
      }
    });

    askBtn.addEventListener('click', () => {
      window.parent.postMessage({ type: 'plugin:request-sref' }, '*');
    });

    copyBtn.addEventListener('click', handleCopy);

    window.parent.postMessage({ type: 'plugin:ready' }, '*');
  </script>
</body>
</html>
